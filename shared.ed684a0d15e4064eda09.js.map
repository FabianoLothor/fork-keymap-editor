{"version":3,"file":"shared.ed684a0d15e4064eda09.js","mappings":"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","sources":["webpack:///../api/packages/zmk-data/behaviors.js","webpack:///../api/packages/zmk-data/keycode-mappings.js","webpack:///../api/packages/zmk-data/keycodes.js","webpack:///../api/packages/zmk-data/parameters.js"],"sourcesContent":["const merge = require('lodash/merge')\nconst isMatch = require('lodash/isMatch')\nconst uniq = require('lodash/uniq')\n\n/** @typedef {('string' | 'boolean' | 'int' | 'array' | 'phandle' | 'phandles' | 'phandle-array' | 'integer-union')} PropertyType */\n/** @typedef {{ type: PropertyType, required?: boolean, const?: any, default?: any, enum?: Array<any>, description?: string }} PropertyDefinition */\n/** @typedef {Object.<string, PropertyDefinition>} Properties */\n/** @typedef {{ description?: string, compatible: string, include: string, properties: Properties }} BehaviorSchema  */\n/** @typedef {Object.<string, BehaviorSchema} BehaviorSchemas */\n/** @typedef {} BehaviorSchema */\n\n/** @type {BehaviorSchemas} */\nconst behaviorSchemas = require('./data/extracted-data/behavior-schemas.json')\n\n/** @typedef {{ parsed: any, raw: string, useRaw?: boolean }} PropertyValue */\n/** @typedef {Object.<string, PropertyValue} ParsedProperties */\n/** @typedef {{ code: string, compatible: string, '#binding-cells': number, properties: ParsedProperties }} Behavior */\n\n/** @type {Array<Behavior>} */\nconst behaviorBindings = require('./data/extracted-data/behaviors.json')\n/** @type {Array<Behavior>} */\nconst behaviorAdditions = require('./data/overlay-data/behaviors-additions.json')\nconst behaviorSchemaOverlays = require('./data/overlay-data/behavior-schemas-overlay.json')\nconst behaviorOverlays = require('./data/overlay-data/behaviors-overlay.json')\n\nbehaviorBindings.push(...behaviorAdditions)\n\nfunction mergeBehaviorOverlays (base, overlays) {\n  const baseValues = Array.isArray(base) ? base : Object.values(base)\n\n  for (const value of baseValues) {\n    for (const { match, ...overlay } of overlays) {\n      if (isMatch(value, match)) {\n        merge(value, overlay)\n      }\n    }\n  }\n}\n\nmergeBehaviorOverlays(behaviorSchemas, behaviorSchemaOverlays)\nmergeBehaviorOverlays(behaviorBindings, behaviorOverlays)\n\nconst standardBehaviorIncludeFiles = uniq(\n  behaviorOverlays.flatMap(overlay => overlay.includes || [])\n)\n\nfor (const behavior of behaviorBindings) {\n  const schema = behaviorSchemas[behavior.compatible]\n  merge(behavior, { schema })\n}\n\nmodule.exports = {\n  behaviorSchemas,\n  behaviorBindings,\n  behaviorSchemaOverlays,\n  standardBehaviorIncludeFiles\n}\n","const singleValue = value => ({ value: '&kp', params: [{ value, params: [] }] })\n\nconst patternMappings = [\n  { pattern: /^[0-9]$/, convert: digit => singleValue(`N${digit}`) },\n  { pattern: /^[a-z]$/, convert: char => singleValue(char.toUpperCase()) },\n  {\n    pattern: /^[A-Z]$/,\n    convert: char => ({\n      value: '&kp',\n      params: [{\n        value: 'LS',\n        params: [{\n          value: char.toUpperCase(),\n          params: []\n        }]\n      }]\n    })\n  }\n]\n\nconst simpleMappings = {\n  '!': singleValue('EXCL'),\n  '@': singleValue('AT'),\n  '#': singleValue('POUND'),\n  '$': singleValue('DLLR'),\n  '%': singleValue('PRCNT'),\n  '^': singleValue('CARET'),\n  '&': singleValue('AMPS'),\n  '*': singleValue('STAR'),\n  '(': singleValue('LPAR'),\n  ')': singleValue('RPAR'),\n  '\\n': singleValue('RET'),\n  ' ': singleValue('SPACE'),\n  '-': singleValue('MINUS'),\n  '_': singleValue('UNDER'),\n  '=': singleValue('EQUAL'),\n  '+': singleValue('PLUS'),\n  '[': singleValue('LBKT'),\n  ']': singleValue('LBRC'),\n  '{': singleValue('RBKT'),\n  '}': singleValue('RBRC'),\n  '\\\\': singleValue('BSLH'),\n  '|': singleValue('PIPE'),\n  '': singleValue('TILDE2'),\n  ';': singleValue('SEMI'),\n  ':': singleValue('COLON'),\n  '\\'': singleValue('SQT'),\n  '\"': singleValue('DQT'),\n  '`': singleValue('GRAVE'),\n  '~': singleValue('TILDE'),\n  ',': singleValue('COMMA'),\n  '<': singleValue('LT'),\n  '.': singleValue('DOT'),\n  '>': singleValue('GT'),\n  '/': singleValue('FSLH'),\n  '?': singleValue('QMARK')\n}\n\nfunction mapCharacter (char) {\n  if (simpleMappings[char]) {\n    return simpleMappings[char]\n  }\n\n  for (const { pattern, convert } of patternMappings) {\n    if (char.match(pattern)) {\n      return convert(char)\n    }\n  }\n}\n\nmodule.exports = {\n  mapCharacter\n}\n","const keycodes = require('./data/extracted-data/keycodes.json')\nconst keycodeGlyphs = {\n  basic: require('./data/overlay-data/keycode-glyphs.json'),\n  unicode: require('./data/overlay-data/keycode-glyphs-unicode.json'),\n  platforms: {\n    mac: require('./data/overlay-data/keycode-glyphs-macos.json'),\n    win: require('./data/overlay-data/keycode-glyphs-windows.json')\n  }\n}\n\nmodule.exports = {\n  keycodes,\n  keycodeGlyphs\n}\n","const { times } = require('lodash')\nconst { behaviorSchemas, behaviorBindings } = require('./behaviors')\n\n/**\n * Parsing keymap gives us a number of custom behaviour definitions\n * Some custom behaviours may reference other behaviours\n * Some custom behaviours may reference other custom behaviours\n *\n * We need to add all new behaviour to a new map upon loading\n * After populating the map with all new behaviours we can resolve bind params\n *\n * Keep a list of \"visited\" behaviours\n * For each behaviour\n * For each behaviour referenced in bindings\n * Resolve behaviour reference to get params list\n * If behaviour reference already exists in list of visited behaviours, bail\n * If number of references to resolve exceeds X, bail\n */\n\nfunction BehaviorResolutionError (message) {\n  this.message = message\n  this.name = 'BehaviorResolutionError'\n}\n\n/** @typedef {string} Identifier */\n/** @typedef {string} Label */\n/** @typedef {{ parsed: any, raw: string, useRaw?: boolean }} PropertyValue */\n/** @typedef {Object.<string, PropertyValue>} Properties */\n/** @typedef {{ name: string, labels: Array<string>, properties: Properties }} ParsedBehavior  */\n\nfunction parseNumBindingCells (behavior) {\n  const parsed = behavior.properties?.['#binding-cells']?.parsed\n\n  if (typeof parsed === 'number') {\n    return parsed\n  }\n\n  // For unrecognized behaviors we don't have the schema to parse the\n  // \"#binding-cells\" property like we'd expect, so let's assume its a single\n  // integer literal and parse the raw value\n  const raw = behavior.properties?.['#binding-cells']?.raw || '<>'\n  const match = raw.match(/<(\\d+)>/)\n\n  if (match) {\n    return Number(match[1])\n  }\n}\n\nfunction behaviorMap (map, behavior) {\n  for (const label of behavior.labels) {\n    map[`&${label}`] = behavior\n  }\n  return map\n}\n\n/**\n * Attempt to provide parameter types for behaviours with binding-cells.\n * @param {Array<ParsedBehavior>} behaviors - custom behavior definitions\n */\nfunction resolveBehaviorParams (behaviors) {\n  const standardBindingsMap = behaviorBindings.reduce(behaviorMap, {})\n  // Here we attempt to resolve the binding to a \"known\" behaviour for which\n  // I have already manually described the parameters. Failing that, this\n  // would fall back to a single \"code\" parameter for each. This assumes\n  // that a custom hold-tap wouldn't want something like \"hold for layer\"\n  // and \"tap to connect to BT profile 1\".\n  const newBindingsMap = behaviors.reduce(behaviorMap, {})\n\n  /**\n   * @param {ParsedBehavior} behavior\n   * @param {Array<string>} [queue=[]]\n   * @returns {void}\n   */\n  function resolve (behavior, queue = []) {\n    if ('params' in behavior) {\n      return behavior.params\n    }\n\n    const compatible = behavior.properties?.compatible?.parsed\n    const schema = behaviorSchemas[compatible]\n\n    const bindingsType = schema?.properties?.bindings?.type\n    const bindingCells = parseNumBindingCells(behavior)\n    const bindings = (behavior.properties?.bindings?.parsed || [])\n\n    // console.log('resolving for', {\n    //   compatible,\n    //   schema,\n    //   bindingsType,\n    //   bindingCells,\n    //   bindings\n    // })\n\n    if (!bindingCells) {\n      return []\n    }\n\n    // A `bindings` prop of type `phandle-array` means the bindings are already\n    // given along with binding cell values and don't need further params.\n    if (bindingsType === 'phandle-array') {\n      return []\n    }\n\n    if (!bindings.length) {\n      return times(bindingCells, () => ({ type: 'string', raw: true }))\n    }\n\n    // This implementation relies on the existing pattern for behaviors which\n    // reference other behaviors without parameters (hold-tap and sticky-key)\n    // will only provide a single parameter to each referenced behavior without\n    // concerning itself with the referenced behavior's binding cell count.\n    // A possible future exception to this is parameterized macros:\n    //  https://github.com/zmkfirmware/zmk/pull/1232#issuecomment-1478977559\n    // This will require re-visiting this solution.\n    return bindings.reduce((params, binding) => {\n      // This implies the bindings property we're inspecting is actually a\n      // phandles-array type (behavior with params) and not phandle/phandles.\n      // This shouldn't happen and stricter checking earlier on would be wise.\n      if (!binding.startsWith('&')) {\n        return params\n      }\n\n      if (queue.includes(binding)) {\n        throw new BehaviorResolutionError(`Circular reference in bindings: \"&${behavior.labels[0]}\" -> \"${binding}\".`)\n      } else if (queue.length > 3) {\n        throw new BehaviorResolutionError('Reference depth limit exceeded.')\n      }\n\n      const nextBehavior = newBindingsMap[binding] || standardBindingsMap[binding]\n\n      // Not sure if I'm ok with this. Previously the idea was that a behavior\n      // referencing an unrecognized behavior cannot resolve parameters at all,\n      // whereas now it just treats that as having a single raw parameter and\n      // includes an error message property that nothing else uses.\n      if (!nextBehavior) {\n        behavior.error = `Unrecognized behavior binding \"${binding}\".`\n        return [...params, { raw: true }]\n      }\n\n      try {\n        nextBehavior.params = resolve(nextBehavior, [...queue, binding])\n        params.push(nextBehavior.params[0] || { type: 'placeholder' })\n      } catch (error) {\n        if (error instanceof BehaviorResolutionError) {\n          nextBehavior.error = error.message\n          nextBehavior.params = []\n        }\n        throw error\n      }\n\n      return params\n    }, [])\n  }\n\n  for (const behavior of behaviors) {\n    // if (!behavior.properties.bindings) {\n    //   continue\n    // }\n\n    try {\n      behavior.params = resolve(behavior)\n    } catch (error) {\n      if (!(error instanceof BehaviorResolutionError)) {\n        throw error\n      }\n\n      console.error('Failed to resolve behavior parameters', error)\n      behavior.error = error.message\n      behavior.params = times(parseNumBindingCells(behavior) || 0, () => ({ raw: true }))\n    }\n  }\n}\n\nmodule.exports = {\n  resolveBehaviorParams\n}\n"],"names":["merge","require","isMatch","uniq","behaviorSchemas","behaviorBindings","behaviorAdditions","behaviorSchemaOverlays","behaviorOverlays","mergeBehaviorOverlays","base","overlays","baseValues","Array","isArray","Object","values","value","match","overlay","push","standardBehaviorIncludeFiles","flatMap","includes","behavior","schema","compatible","module","exports","singleValue","params","patternMappings","pattern","convert","digit","char","toUpperCase","simpleMappings","mapCharacter","keycodes","keycodeGlyphs","basic","unicode","platforms","mac","win","times","BehaviorResolutionError","message","this","name","parseNumBindingCells","parsed","properties","raw","Number","behaviorMap","map","label","labels","resolveBehaviorParams","behaviors","standardBindingsMap","reduce","newBindingsMap","resolve","queue","bindingsType","bindings","type","bindingCells","length","binding","startsWith","nextBehavior","error","console"],"sourceRoot":""}