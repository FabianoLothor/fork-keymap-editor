{"version":3,"file":"shared.2ff2d7391445f4803144.js","mappings":"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","sources":["webpack://app/../api/packages/zmk-data/behaviors.js","webpack://app/../api/packages/zmk-data/keycode-mappings.js","webpack://app/../api/packages/zmk-data/keycodes.js","webpack://app/../api/packages/zmk-data/parameters.js"],"sourcesContent":["const merge = require('lodash/merge')\nconst isMatch = require('lodash/isMatch')\nconst uniq = require('lodash/uniq')\n\n/** @typedef {('string' | 'boolean' | 'int' | 'array' | 'phandle' | 'phandles' | 'phandle-array' | 'integer-union')} PropertyType */\n/** @typedef {{ type: PropertyType, required?: boolean, const?: any, default?: any, enum?: Array<any>, description?: string }} PropertyDefinition */\n/** @typedef {Object.<string, PropertyDefinition>} Properties */\n/** @typedef {{ description?: string, compatible: string, include: string, properties: Properties }} BehaviorSchema  */\n/** @typedef {Object.<string, BehaviorSchema} BehaviorSchemas */\n/** @typedef {} BehaviorSchema */\n\n/** @type {BehaviorSchemas} */\nconst behaviorSchemas = require('./data/extracted-data/behavior-schemas.json')\n\n/** @typedef {{ parsed: any, raw: string, useRaw?: boolean }} PropertyValue */\n/** @typedef {Object.<string, PropertyValue} ParsedProperties */\n/** @typedef {{ code: string, compatible: string, '#binding-cells': number, properties: ParsedProperties }} Behavior */\n\n/** @type {Array<Behavior>} */\nconst behaviorBindings = require('./data/extracted-data/behaviors.json')\nconst behaviorSchemaOverlays = require('./data/overlay-data/behavior-schemas-overlay.json')\nconst behaviorOverlays = require('./data/overlay-data/behaviors-overlay.json')\n\nfunction mergeBehaviorOverlays (base, overlays) {\n  const baseValues = Array.isArray(base) ? base : Object.values(base)\n\n  for (const value of baseValues) {\n    for (const { match, ...overlay } of overlays) {\n      if (isMatch(value, match)) {\n        merge(value, overlay)\n      }\n    }\n  }\n}\n\nmergeBehaviorOverlays(behaviorSchemas, behaviorSchemaOverlays)\nmergeBehaviorOverlays(behaviorBindings, behaviorOverlays)\n\nconst standardBehaviorIncludeFiles = uniq(\n  behaviorOverlays.flatMap(overlay => overlay.includes || [])\n)\n\nfor (const behavior of behaviorBindings) {\n  const schema = behaviorSchemas[behavior.compatible]\n  merge(behavior, { schema })\n}\n\nmodule.exports = {\n  behaviorSchemas,\n  behaviorBindings,\n  behaviorSchemaOverlays,\n  standardBehaviorIncludeFiles\n}\n","const singleValue = value => ({ value: '&kp', params: [{ value, params: [] }] })\n\nconst patternMappings = [\n  { pattern: /^[0-9]$/, convert: digit => singleValue(`N${digit}`) },\n  { pattern: /^[a-z]$/, convert: char => singleValue(char.toUpperCase()) },\n  {\n    pattern: /^[A-Z]$/,\n    convert: char => ({\n      value: '&kp',\n      params: [{\n        value: 'LS',\n        params: [{\n          value: char.toUpperCase(),\n          params: []\n        }]\n      }]\n    })\n  }\n]\n\nconst simpleMappings = {\n  '!': singleValue('EXCL'),\n  '@': singleValue('AT'),\n  '#': singleValue('POUND'),\n  '$': singleValue('DLLR'),\n  '%': singleValue('PRCNT'),\n  '^': singleValue('CARET'),\n  '&': singleValue('AMPS'),\n  '*': singleValue('STAR'),\n  '(': singleValue('LPAR'),\n  ')': singleValue('RPAR'),\n  '\\n': singleValue('RET'),\n  ' ': singleValue('SPACE'),\n  '-': singleValue('MINUS'),\n  '_': singleValue('UNDER'),\n  '=': singleValue('EQUAL'),\n  '+': singleValue('PLUS'),\n  '[': singleValue('LBKT'),\n  ']': singleValue('LBRC'),\n  '{': singleValue('RBKT'),\n  '}': singleValue('RBRC'),\n  '\\\\': singleValue('BSLH'),\n  '|': singleValue('PIPE'),\n  '': singleValue('TILDE2'),\n  ';': singleValue('SEMI'),\n  ':': singleValue('COLON'),\n  '\\'': singleValue('SQT'),\n  '\"': singleValue('DQT'),\n  '`': singleValue('GRAVE'),\n  '~': singleValue('TILDE'),\n  ',': singleValue('COMMA'),\n  '<': singleValue('LT'),\n  '.': singleValue('DOT'),\n  '>': singleValue('GT'),\n  '/': singleValue('FSLH'),\n  '?': singleValue('QMARK')\n}\n\nfunction mapCharacter (char) {\n  if (simpleMappings[char]) {\n    return simpleMappings[char]\n  }\n\n  for (const { pattern, convert } of patternMappings) {\n    if (char.match(pattern)) {\n      return convert(char)\n    }\n  }\n}\n\nmodule.exports = {\n  mapCharacter\n}\n","const keycodes = require('./data/extracted-data/keycodes.json')\nconst keycodeGlyphs = {\n  basic: require('./data/overlay-data/keycode-glyphs.json'),\n  unicode: require('./data/overlay-data/keycode-glyphs-unicode.json'),\n  platforms: {\n    mac: require('./data/overlay-data/keycode-glyphs-macos.json'),\n    win: require('./data/overlay-data/keycode-glyphs-windows.json')\n  }\n}\n\nmodule.exports = {\n  keycodes,\n  keycodeGlyphs\n}\n","const { keyBy, times } = require('lodash')\nconst { behaviorSchemas, behaviorBindings } = require('./behaviors')\n\n/**\n * Parsing keymap gives us a number of custom behaviour definitions\n * Some custom behaviours may reference other behaviours\n * Some custom behaviours may reference other custom behaviours\n *\n * We need to add all new behaviour to a new map upon loading\n * After populating the map with all new behaviours we can resolve bind params\n *\n * Keep a list of \"visited\" behaviours\n * For each behaviour\n * For each behaviour referenced in bindings\n * Resolve behaviour reference to get params list\n * If behaviour reference already exists in list of visited behaviours, bail\n * If number of references to resolve exceeds X, bail\n */\n\nfunction BehaviorResolutionError (message) {\n  this.message = message\n  this.name = 'BehaviorResolutionError'\n}\n\n/** @typedef {string} Identifier */\n/** @typedef {string} Label */\n/** @typedef {{ parsed: any, raw: string, useRaw?: boolean }} PropertyValue */\n/** @typedef {Object.<string, PropertyValue>} Properties */\n/** @typedef {{ name: string, labels: Array<string>, properties: Properties }} ParsedBehavior  */\n\nfunction parseNumBindingCells (behavior) {\n  const parsed = behavior.properties?.['#binding-cells']?.parsed\n\n  if (typeof parsed === 'number') {\n    return parsed\n  }\n\n  // For unrecognized behaviors we don't have the schema to parse the\n  // \"#binding-cells\" property like we'd expect, so let's assume its a single\n  // integer literal and parse the raw value\n  const raw = behavior.properties?.['#binding-cells']?.raw || '<>'\n  const match = raw.match(/<(\\d+)>/)\n\n  if (match) {\n    return Number(match[1])\n  }\n}\n\n/**\n * Attempt to provide parameter types for behaviours with binding-cells.\n * @param {Array<ParsedBehavior>} behaviors - custom behavior definitions\n */\nfunction resolveBehaviorParams (behaviors) {\n  const bindingsByCode = keyBy(behaviorBindings, 'code')\n  // Here we attempt to resolve the binding to a \"known\" behaviour for which\n  // I have already manually described the parameters. Failing that, this\n  // would fall back to a single \"code\" parameter for each. This assumes\n  // that a custom hold-tap wouldn't want something like \"hold for layer\"\n  // and \"tap to connect to BT profile 1\".\n  const newBindingsMap = keyBy(behaviors, behavior => `&${behavior.labels[0]}`)\n\n  /**\n   * @param {ParsedBehavior} behavior\n   * @param {Array<string>} [queue=[]]\n   * @returns {void}\n   */\n  function resolve (behavior, queue = []) {\n    if ('params' in behavior) {\n      return behavior.params\n    }\n\n    const compatible = behavior.properties?.compatible?.parsed\n    const schema = behaviorSchemas[compatible]\n\n    const bindingsType = schema?.properties?.bindings?.type\n    const bindingCells = parseNumBindingCells(behavior)\n    const bindings = (behavior.properties?.bindings?.parsed || [])\n\n    // console.log('resolving for', {\n    //   compatible,\n    //   schema,\n    //   bindingsType,\n    //   bindingCells,\n    //   bindings\n    // })\n\n    if (!bindingCells) {\n      return []\n    }\n\n    // A `bindings` prop of type `phandle-array` means the bindings are already\n    // given along with binding cell values and don't need further params.\n    if (bindingsType === 'phandle-array') {\n      return []\n    }\n\n    if (!bindings.length) {\n      return times(bindingCells, () => ({ type: 'string', raw: true }))\n    }\n\n    const nestedParams = bindings.flatMap(binding => {\n      if (!binding.startsWith('&')) {\n        return []\n      }\n\n      if (queue.includes(binding)) {\n        throw new BehaviorResolutionError(`Circular reference in bindings: \"${behavior.binding}\" -> \"${binding}\".`)\n      } else if (queue.length > 3) {\n        throw new BehaviorResolutionError('Reference depth limit exceeded.')\n      }\n\n      const nextBehavior = newBindingsMap[binding] || bindingsByCode[binding]\n      if (nextBehavior) {\n        try {\n          nextBehavior.params = resolve(nextBehavior, [...queue, binding])\n          return nextBehavior.params\n        } catch (error) {\n          if (error instanceof BehaviorResolutionError) {\n            nextBehavior.error = error.message\n            nextBehavior.params = []\n          }\n          throw error\n        }\n      }\n\n      throw new BehaviorResolutionError(`Unrecognized behavior binding \"${binding}\".`)\n    })\n\n    return times(bindingCells, i => nestedParams[i] || { type: 'placeholder' })\n  }\n\n  for (const behavior of behaviors) {\n    // if (!behavior.properties.bindings) {\n    //   continue\n    // }\n\n    try {\n      behavior.params = resolve(behavior)\n    } catch (error) {\n      if (!(error instanceof BehaviorResolutionError)) {\n        throw error\n      }\n\n      console.error('Failed to resolve behavior parameters', error)\n      behavior.error = error.message\n      behavior.params = times(parseNumBindingCells(behavior) || 0, () => ({ type: 'raw' }))\n    }\n  }\n}\n\nmodule.exports = {\n  resolveBehaviorParams\n}\n"],"names":["merge","require","isMatch","uniq","behaviorSchemas","behaviorBindings","behaviorSchemaOverlays","behaviorOverlays","mergeBehaviorOverlays","base","overlays","baseValues","Array","isArray","Object","values","value","match","overlay","standardBehaviorIncludeFiles","flatMap","includes","behavior","schema","compatible","module","exports","singleValue","params","patternMappings","pattern","convert","digit","char","toUpperCase","simpleMappings","mapCharacter","keycodes","keycodeGlyphs","basic","unicode","platforms","mac","win","keyBy","times","BehaviorResolutionError","message","this","name","parseNumBindingCells","parsed","properties","raw","Number","resolveBehaviorParams","behaviors","bindingsByCode","newBindingsMap","labels","resolve","queue","bindingsType","bindings","type","bindingCells","length","nestedParams","binding","startsWith","nextBehavior","error","i","console"],"sourceRoot":""}