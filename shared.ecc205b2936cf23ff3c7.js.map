{"version":3,"file":"shared.ecc205b2936cf23ff3c7.js","mappings":"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","sources":["webpack:///../api/packages/zmk-data/behaviors.js","webpack:///../api/packages/zmk-data/keycode-mappings.js","webpack:///../api/packages/zmk-data/keycodes.js","webpack:///../api/packages/zmk-data/parameters.js"],"sourcesContent":["const merge = require('lodash/merge')\nconst isMatch = require('lodash/isMatch')\nconst uniq = require('lodash/uniq')\n\n/** @typedef {('string' | 'boolean' | 'int' | 'array' | 'phandle' | 'phandles' | 'phandle-array' | 'integer-union')} PropertyType */\n/** @typedef {{ type: PropertyType, required?: boolean, const?: any, default?: any, enum?: Array<any>, description?: string }} PropertyDefinition */\n/** @typedef {Object.<string, PropertyDefinition>} Properties */\n/** @typedef {{ description?: string, compatible: string, include: string, properties: Properties }} BehaviorSchema  */\n/** @typedef {Object.<string, BehaviorSchema} BehaviorSchemas */\n/** @typedef {} BehaviorSchema */\n\n/** @type {BehaviorSchemas} */\nconst behaviorSchemas = require('./data/extracted-data/behavior-schemas.json')\n/** @type {BehaviorSchemas} */\nconst behaviorSchemaAdditions = require('./data/overlay-data/behavior-schemas-additions.json')\n\n/** @typedef {{ parsed: any, raw: string, useRaw?: boolean }} PropertyValue */\n/** @typedef {Object.<string, PropertyValue} ParsedProperties */\n/** @typedef {{ code: string, compatible: string, '#binding-cells': number, properties: ParsedProperties }} Behavior */\n\n/** @type {Array<Behavior>} */\nconst behaviorBindings = require('./data/extracted-data/behaviors.json')\n/** @type {Array<Behavior>} */\nconst behaviorAdditions = require('./data/overlay-data/behaviors-additions.json')\nconst behaviorSchemaOverlays = require('./data/overlay-data/behavior-schemas-overlay.json')\nconst behaviorOverlays = require('./data/overlay-data/behaviors-overlay.json')\n\nObject.assign(behaviorSchemas, behaviorSchemaAdditions)\nbehaviorBindings.push(...behaviorAdditions)\n\nfunction mergeBehaviorOverlays (base, overlays) {\n  const baseValues = Array.isArray(base) ? base : Object.values(base)\n\n  for (const value of baseValues) {\n    for (const { match, ...overlay } of overlays) {\n      if (isMatch(value, match)) {\n        merge(value, overlay)\n      }\n    }\n  }\n}\n\nmergeBehaviorOverlays(behaviorSchemas, behaviorSchemaOverlays)\nmergeBehaviorOverlays(behaviorBindings, behaviorOverlays)\n\nconst standardBehaviorIncludeFiles = uniq(\n  behaviorOverlays.flatMap(overlay => overlay.includes || [])\n)\n\nfor (const behavior of behaviorBindings) {\n  const schema = behaviorSchemas[behavior.compatible]\n  merge(behavior, { schema })\n}\n\nmodule.exports = {\n  behaviorSchemas,\n  behaviorBindings,\n  behaviorOverlays,\n  behaviorSchemaOverlays,\n  standardBehaviorIncludeFiles,\n  mergeBehaviorOverlays\n}\n","const singleValue = value => ({ value: '&kp', params: [{ value, params: [] }] })\n\nconst patternMappings = [\n  { pattern: /^[0-9]$/, convert: digit => singleValue(`N${digit}`) },\n  { pattern: /^[a-z]$/, convert: char => singleValue(char.toUpperCase()) },\n  {\n    pattern: /^[A-Z]$/,\n    convert: char => ({\n      value: '&kp',\n      params: [{\n        value: 'LS',\n        params: [{\n          value: char.toUpperCase(),\n          params: []\n        }]\n      }]\n    })\n  }\n]\n\nconst simpleMappings = {\n  '!': singleValue('EXCL'),\n  '@': singleValue('AT'),\n  '#': singleValue('POUND'),\n  '$': singleValue('DLLR'),\n  '%': singleValue('PRCNT'),\n  '^': singleValue('CARET'),\n  '&': singleValue('AMPS'),\n  '*': singleValue('STAR'),\n  '(': singleValue('LPAR'),\n  ')': singleValue('RPAR'),\n  '\\n': singleValue('RET'),\n  ' ': singleValue('SPACE'),\n  '-': singleValue('MINUS'),\n  '_': singleValue('UNDER'),\n  '=': singleValue('EQUAL'),\n  '+': singleValue('PLUS'),\n  '[': singleValue('LBKT'),\n  ']': singleValue('LBRC'),\n  '{': singleValue('RBKT'),\n  '}': singleValue('RBRC'),\n  '\\\\': singleValue('BSLH'),\n  '|': singleValue('PIPE'),\n  '': singleValue('TILDE2'),\n  ';': singleValue('SEMI'),\n  ':': singleValue('COLON'),\n  '\\'': singleValue('SQT'),\n  '\"': singleValue('DQT'),\n  '`': singleValue('GRAVE'),\n  '~': singleValue('TILDE'),\n  ',': singleValue('COMMA'),\n  '<': singleValue('LT'),\n  '.': singleValue('DOT'),\n  '>': singleValue('GT'),\n  '/': singleValue('FSLH'),\n  '?': singleValue('QMARK')\n}\n\nfunction mapCharacter (char) {\n  if (simpleMappings[char]) {\n    return simpleMappings[char]\n  }\n\n  for (const { pattern, convert } of patternMappings) {\n    if (char.match(pattern)) {\n      return convert(char)\n    }\n  }\n}\n\nmodule.exports = {\n  mapCharacter\n}\n","const keycodes = require('./data/extracted-data/keycodes.json')\nconst keycodeGlyphs = {\n  basic: require('./data/overlay-data/keycode-glyphs.json'),\n  unicode: require('./data/overlay-data/keycode-glyphs-unicode.json'),\n  platforms: {\n    mac: require('./data/overlay-data/keycode-glyphs-macos.json'),\n    win: require('./data/overlay-data/keycode-glyphs-windows.json')\n  }\n}\n\nmodule.exports = {\n  keycodes,\n  keycodeGlyphs\n}\n","const times = require('lodash/times')\nconst { behaviorSchemas, behaviorBindings } = require('./behaviors')\n\n/**\n * Parsing keymap gives us a number of custom behaviour definitions\n * Some custom behaviours may reference other behaviours\n * Some custom behaviours may reference other custom behaviours\n *\n * We need to add all new behaviour to a new map upon loading\n * After populating the map with all new behaviours we can resolve bind params\n *\n * Keep a list of \"visited\" behaviours\n * For each behaviour\n * For each behaviour referenced in bindings\n * Resolve behaviour reference to get params list\n * If behaviour reference already exists in list of visited behaviours, bail\n * If number of references to resolve exceeds X, bail\n */\n\nfunction BehaviorResolutionError (message) {\n  this.message = message\n  this.name = 'BehaviorResolutionError'\n}\n\n/** @typedef {string} Identifier */\n/** @typedef {string} Label */\n/** @typedef {{ parsed: any, raw: string, useRaw?: boolean }} PropertyValue */\n/** @typedef {Object.<string, PropertyValue>} Properties */\n/** @typedef {{ name: string, labels: Array<string>, properties: Properties }} ParsedBehavior  */\n\nfunction parseNumBindingCells (behavior, prop = '#binding-cells') {\n  const parsed = behavior.properties?.[prop]?.parsed\n\n  if (typeof parsed === 'number') {\n    return parsed\n  }\n\n  // For unrecognized behaviors we don't have the schema to parse the\n  // \"#binding-cells\" property like we'd expect, so let's assume its a single\n  // integer literal and parse the raw value\n  const raw = behavior.properties?.[prop]?.raw || '<>'\n  const match = raw.match(/<(\\d+)>/)\n\n  if (match) {\n    return Number(match[1])\n  }\n}\n\nfunction behaviorMap (map, behavior) {\n  for (const label of behavior.labels) {\n    map[`&${label}`] = behavior\n  }\n  return map\n}\n\n/**\n * Attempt to provide parameter types for behaviours with binding-cells.\n * @param {Array<ParsedBehavior>} behaviors - custom behavior definitions\n */\nfunction resolveBehaviorParams (behaviors) {\n  const standardBindingsMap = behaviorBindings.reduce(behaviorMap, {})\n  // Here we attempt to resolve the binding to a \"known\" behaviour for which\n  // I have already manually described the parameters. Failing that, this\n  // would fall back to a single \"code\" parameter for each. This assumes\n  // that a custom hold-tap wouldn't want something like \"hold for layer\"\n  // and \"tap to connect to BT profile 1\".\n  const newBindingsMap = behaviors.reduce(behaviorMap, {})\n\n  /**\n   * @param {ParsedBehavior} behavior\n   * @param {Array<string>} [queue=[]]\n   * @returns {void}\n   */\n  function resolve (behavior, queue = []) {\n    if ('params' in behavior) {\n      return behavior.params\n    }\n\n    const compatible = behavior.properties?.compatible?.parsed\n    const schema = behaviorSchemas[compatible]\n\n    const bindingsType = schema?.properties?.bindings?.type\n    const bindingCells = parseNumBindingCells(behavior) ?? parseNumBindingCells(behavior, '#sensor-binding-cells')\n    const bindings = (behavior.properties?.bindings?.parsed || [])\n\n    // console.log('resolving for', {\n    //   compatible,\n    //   schema,\n    //   bindingsType,\n    //   bindingCells,\n    //   bindings\n    // })\n\n    if (!bindingCells) {\n      return []\n    }\n\n    // A `bindings` prop of type `phandle-array` means the bindings are already\n    // given along with binding cell values and don't need further params.\n    if (bindingsType === 'phandle-array') {\n      return []\n    }\n\n    if (!bindings.length) {\n      return times(bindingCells, () => ({ type: 'string', raw: true }))\n    }\n\n    // This implementation relies on the existing pattern for behaviors which\n    // reference other behaviors without parameters (hold-tap and sticky-key)\n    // will only provide a single parameter to each referenced behavior without\n    // concerning itself with the referenced behavior's binding cell count.\n    // A possible future exception to this is parameterized macros:\n    //  https://github.com/zmkfirmware/zmk/pull/1232#issuecomment-1478977559\n    // This will require re-visiting this solution.\n    return bindings.reduce((params, binding) => {\n      // This implies the bindings property we're inspecting is actually a\n      // phandles-array type (behavior with params) and not phandle/phandles.\n      // This shouldn't happen and stricter checking earlier on would be wise.\n      if (!binding.startsWith('&')) {\n        return params\n      }\n\n      if (queue.includes(binding)) {\n        throw new BehaviorResolutionError(`Circular reference in bindings: \"&${behavior.labels[0]}\" -> \"${binding}\".`)\n      } else if (queue.length > 3) {\n        throw new BehaviorResolutionError('Reference depth limit exceeded.')\n      }\n\n      const nextBehavior = newBindingsMap[binding] || standardBindingsMap[binding]\n\n      // Not sure if I'm ok with this. Previously the idea was that a behavior\n      // referencing an unrecognized behavior cannot resolve parameters at all,\n      // whereas now it just treats that as having a single raw parameter and\n      // includes an error message property that nothing else uses.\n      if (!nextBehavior) {\n        behavior.error = `Unrecognized behavior binding \"${binding}\".`\n        return [...params, { raw: true }]\n      }\n\n      try {\n        nextBehavior.params = resolve(nextBehavior, [...queue, binding])\n        params.push(nextBehavior.params[0] || { type: 'placeholder' })\n      } catch (error) {\n        if (error instanceof BehaviorResolutionError) {\n          nextBehavior.error = error.message\n          nextBehavior.params = []\n        }\n        throw error\n      }\n\n      return params\n    }, [])\n  }\n\n  for (const behavior of behaviors) {\n    // if (!behavior.properties.bindings) {\n    //   continue\n    // }\n\n    try {\n      behavior.params = resolve(behavior)\n    } catch (error) {\n      if (!(error instanceof BehaviorResolutionError)) {\n        throw error\n      }\n\n      console.error('Failed to resolve behavior parameters', error)\n      behavior.error = error.message\n      behavior.params = times(parseNumBindingCells(behavior) || 0, () => ({ raw: true }))\n    }\n  }\n}\n\nmodule.exports = {\n  resolveBehaviorParams\n}\n"],"names":["merge","require","isMatch","uniq","behaviorSchemas","behaviorSchemaAdditions","behaviorBindings","behaviorAdditions","behaviorSchemaOverlays","behaviorOverlays","mergeBehaviorOverlays","base","overlays","baseValues","Array","isArray","Object","values","value","match","overlay","assign","push","standardBehaviorIncludeFiles","flatMap","includes","behavior","schema","compatible","module","exports","singleValue","params","patternMappings","pattern","convert","digit","char","toUpperCase","simpleMappings","mapCharacter","keycodes","keycodeGlyphs","basic","unicode","platforms","mac","win","times","BehaviorResolutionError","message","this","name","parseNumBindingCells","prop","parsed","properties","raw","Number","behaviorMap","map","label","labels","resolveBehaviorParams","behaviors","standardBindingsMap","reduce","newBindingsMap","resolve","queue","bindingsType","bindings","type","bindingCells","length","binding","startsWith","nextBehavior","error","console"],"sourceRoot":""}